single_input: _NEWLINE | simple_stmt | compound_stmt _NEWLINE
file_input: (_NEWLINE | stmt)*
eval_input: rekkyo _NEWLINE*



// statements
?stmt: simple_stmt | compound_stmt
?simple_stmt: small_stmt (";" small_stmt)* [";"] _NEWLINE
?small_stmt: (normal_stmt | flow_stmt | import_stmt)



// import statements
import_stmt: import_name | import_from
import_name: "import" dotted_as_names
import_from: "from" (dots? dotted_name | dots) "import" ("*" | "(" import_as_names ")" | import_as_names)
!dots: "."+
import_as_name: NAME ["as" NAME]
dotted_as_name: dotted_name ["as" NAME]
import_as_names: import_as_name ("," import_as_name)* [","]
dotted_as_names: dotted_as_name ("," dotted_as_name)*
dotted_name: NAME ("." NAME)*



// compund statements
compound_stmt: if_stmt | while_stmt | for_stmt | funcdef | classdef
if_stmt: "if" level2_expr ":" suite ("elif" level2_expr ":" suite)* ["else" ":" suite]
while_stmt: "while" level2_expr ":" suite ["else" ":" suite]
for_stmt: "for" exprlist "in" rekkyo ":" suite ["else" ":" suite]
funcdef: "proc" NAME "(" parameters? ")" [":" type] "=" suite
classdef: "class" NAME ["(" [arguments] ")"] ":" suite

suite: simple_stmt | _NEWLINE _INDENT stmt+ _DEDENT



// control statements
?flow_stmt: pass_stmt | break_stmt | continue_stmt | return_stmt
pass_stmt: "pass"
break_stmt: "break"
continue_stmt: "continue"
return_stmt: "return" [rekkyo]



// normal statements
?normal_stmt: declare_with_type_stmt
            | declare_with_value_stmt
            | declare_with_type_and_value_stmt
            | assign_stmt
            | just_expr_stmt

declare_with_type_stmt: "var" new_symbol ":" type
declare_with_value_stmt: "var" new_symbol "=" level2_expr
declare_with_type_and_value_stmt: "var" new_symbol ":" type "=" level2_expr
assign_stmt: rekkyo "=" rekkyo
just_expr_stmt: level2_expr




// expressions
?level2_expr: or_expr ("if" or_expr "else" level2_expr)?
?level3_expr: or_expr
?or_expr: xor_expr ("or" xor_expr)*
?xor_expr: and_expr ("xor" and_expr)*
?and_expr: not_expr ("and" not_expr)*
?not_expr: "not" not_expr -> not
         | comparison_expr
?comparison_expr: addsub_expr (_comp_op addsub_expr)*
?addsub_expr: muldiv_expr (_addsub_op muldiv_expr)*
?muldiv_expr: prefix_expr (_muldiv_op prefix_expr)*
?prefix_expr: _prefix_op prefix_expr
            | power_expr
?power_expr: atom_expr ("^" prefix_expr)?

!_prefix_op: "+"|"-"|"~"
!_muldiv_op: "*"|"@"|"/"|"%"|"//"
!_addsub_op: "+"|"-"
!_comp_op: "<"|">"|"=="|">="|"<="|"<>"|"!="|"in"|"notin"|"is"|"isnot"

?atom_expr: atom_expr "(" [arguments] ")"    -> funccall
          | atom_expr "[" rekkyo "]"  -> getitem
          | atom_expr "." NAME               -> getattr
          | atom

?atom: "(" [rekkyo] ")" -> tuple
     | "[" [rekkyo] "]"  -> list
     | symbol
     | number
     | string+
     | "(" level2_expr ")"
     | "..." -> ellipsis
     | "None"    -> const_none
     | "True"    -> const_true
     | "False"   -> const_false



// iterative
parameters: param ("," param)*
?param: symbol ":" type ["=" level2_expr]

exprlist: addsub_expr ("," addsub_expr)* [","]
arguments: argvalue ("," argvalue)* 
?argvalue: level2_expr ("=" level2_expr)?
rekkyo: level2_expr ("," level2_expr)* [","]



// omajinai
encoding_decl: NAME



symbol: NAME
new_symbol: NAME
type: NAME



// elements
number: DEC_NUMBER | HEX_NUMBER | BIN_NUMBER | OCT_NUMBER | FLOAT_NUMBER | IMAG_NUMBER
string: STRING | LONG_STRING

NAME: /[a-zA-Z_]\w*/
COMMENT: /#[^\n]*/
_NEWLINE: ( /\r?\n[\t ]*/ | COMMENT )+

STRING : /[ubf]?r?("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
LONG_STRING: /[ubf]?r?(""".*?(?<!\\)(\\\\)*?"""|'''.*?(?<!\\)(\\\\)*?''')/is

DEC_NUMBER: /0|[1-9]\d*/i
HEX_NUMBER.2: /0x[\da-f]*/i
OCT_NUMBER.2: /0o[0-7]*/i
BIN_NUMBER.2 : /0b[0-1]*/i
FLOAT_NUMBER.2: /((\d+\.\d*|\.\d+)(e[-+]?\d+)?|\d+(e[-+]?\d+))/i
IMAG_NUMBER.2: /\d+j/i | FLOAT_NUMBER "j"i


%ignore /[\t \f]+/  // WS
%ignore /\\[\t \f]*\r?\n/   // LINE_CONT
%ignore COMMENT
%declare _INDENT _DEDENT
