single_input: _NEWLINE | simple_stmt | compound_stmt _NEWLINE
file_input: (_NEWLINE | stmt)*
eval_input: korenani_list _NEWLINE*

funcdef: "def" NAME "(" parameters? ")" ["->" level2_expr] ":" suite

parameters: paramvalue ("," paramvalue)*
?paramvalue: typedparam ["=" level2_expr]
?typedparam: NAME [":" level2_expr]

varargslist: (vfpdef ["=" level2_expr] ("," vfpdef ["=" level2_expr])* ["," [ "*" [vfpdef] ("," vfpdef ["=" level2_expr])* ["," ["**" vfpdef [","]]] | "**" vfpdef [","]]]
  | "*" [vfpdef] ("," vfpdef ["=" level2_expr])* ["," ["**" vfpdef [","]]]
  | "**" vfpdef [","])

vfpdef: NAME

?stmt: simple_stmt | compound_stmt
?simple_stmt: small_stmt (";" small_stmt)* [";"] _NEWLINE
?small_stmt: (expr_stmt | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | nonlocal_stmt | assert_stmt)
?expr_stmt: korenani_list_star_expr (annassign | augassign korenani_list
         | ("=" korenani_list_star_expr)*)
annassign: ":" level2_expr ["=" level2_expr]
?korenani_list_star_expr: (level2_expr|star_expr) ("," (level2_expr|star_expr))* [","]
!augassign: ("+=" | "-=" | "*=" | "@=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" | "**=" | "//=")
// For normal and annotated assignments, additional restrictions enforced by the interpreter
del_stmt: "del" exprlist
pass_stmt: "pass"
?flow_stmt: break_stmt | continue_stmt | return_stmt
break_stmt: "break"
continue_stmt: "continue"
return_stmt: "return" [korenani_list]
import_stmt: import_name | import_from
import_name: "import" dotted_as_names

import_from: "from" (dots? dotted_name | dots) "import" ("*" | "(" import_as_names ")" | import_as_names)
!dots: "."+
import_as_name: NAME ["as" NAME]
dotted_as_name: dotted_name ["as" NAME]
import_as_names: import_as_name ("," import_as_name)* [","]
dotted_as_names: dotted_as_name ("," dotted_as_name)*
dotted_name: NAME ("." NAME)*
global_stmt: "global" NAME ("," NAME)*
nonlocal_stmt: "nonlocal" NAME ("," NAME)*
assert_stmt: "assert" level2_expr ["," level2_expr]

compound_stmt: if_stmt | while_stmt | for_stmt | funcdef | classdef
if_stmt: "if" level2_expr ":" suite ("elif" level2_expr ":" suite)* ["else" ":" suite]
while_stmt: "while" level2_expr ":" suite ["else" ":" suite]
for_stmt: "for" exprlist "in" korenani_list ":" suite ["else" ":" suite]
suite: simple_stmt | _NEWLINE _INDENT stmt+ _DEDENT






?korenani_list_comp: (level2_expr|star_expr) [comp_for | ("," (level2_expr|star_expr))+ [","] | ","]
subscriptlist: subscript ("," subscript)* [","]
subscript: level2_expr | [level2_expr] ":" [level2_expr] [sliceop]
sliceop: ":" [level2_expr]
exprlist: (addsub_expr|star_expr) ("," (addsub_expr|star_expr))* [","]
korenani_list: level2_expr ("," level2_expr)* [","]

classdef: "class" NAME ["(" [arguments] ")"] ":" suite

arguments: argvalue ("," argvalue)* 
         | level2_expr comp_for

?argvalue: level2_expr ("=" level2_expr)?



comp_iter: comp_for | comp_if
comp_for: "for" exprlist "in" or_expr [comp_iter]
comp_if: "if" level3_expr [comp_iter]





















// wakaran
// wakatta




?level2_expr: or_expr ("if" or_expr "else" level2_expr)?
?level3_expr: or_expr
?or_expr: xor_expr ("or" xor_expr)*
?xor_expr: and_expr ("xor" and_expr)*
?and_expr: not_expr ("and" not_expr)*
?not_expr: "not" not_expr -> not
         | comparison_expr
?comparison_expr: addsub_expr (_comp_op addsub_expr)*
star_expr: "*" addsub_expr
?addsub_expr: muldiv_expr (_addsub_op muldiv_expr)*
?muldiv_expr: prefix_expr (_muldiv_op prefix_expr)*
?prefix_expr: _prefix_op prefix_expr
            | power_expr
?power_expr: atom_expr ("^" prefix_expr)?

!_prefix_op: "+"|"-"|"~"
!_muldiv_op: "*"|"@"|"/"|"%"|"//"
!_addsub_op: "+"|"-"
!_comp_op: "<"|">"|"=="|">="|"<="|"<>"|"!="|"in"|"notin"|"is"|"isnot"


?atom_expr: atom_expr "(" [arguments] ")"    -> funccall
          | atom_expr "[" subscriptlist "]"  -> getitem
          | atom_expr "." NAME               -> getattr
          | atom

?atom: "(" [korenani_list_comp] ")" -> tuple
     | "[" [korenani_list_comp] "]"  -> list
     | NAME -> var
     | number | string+
     | "(" level2_expr ")"
     | "..." -> ellipsis
     | "None"    -> const_none
     | "True"    -> const_true
     | "False"   -> const_false






encoding_decl: NAME // omajinai







number: DEC_NUMBER | HEX_NUMBER | BIN_NUMBER | OCT_NUMBER | FLOAT_NUMBER | IMAG_NUMBER
string: STRING | LONG_STRING

NAME: /[a-zA-Z_]\w*/
COMMENT: /#[^\n]*/
_NEWLINE: ( /\r?\n[\t ]*/ | COMMENT )+


STRING : /[ubf]?r?("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
LONG_STRING: /[ubf]?r?(""".*?(?<!\\)(\\\\)*?"""|'''.*?(?<!\\)(\\\\)*?''')/is

DEC_NUMBER: /0|[1-9]\d*/i
HEX_NUMBER.2: /0x[\da-f]*/i
OCT_NUMBER.2: /0o[0-7]*/i
BIN_NUMBER.2 : /0b[0-1]*/i
FLOAT_NUMBER.2: /((\d+\.\d*|\.\d+)(e[-+]?\d+)?|\d+(e[-+]?\d+))/i
IMAG_NUMBER.2: /\d+j/i | FLOAT_NUMBER "j"i

%ignore /[\t \f]+/  // WS
%ignore /\\[\t \f]*\r?\n/   // LINE_CONT
%ignore COMMENT
%declare _INDENT _DEDENT
